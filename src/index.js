"use strict";

// Homebridge platform plugin that exposes multiple local webhook endpoints and IMAP email triggers
// as HomeKit Motion Sensors. Includes security controls for local-network-only access and per-webhook tokens.

const express = require("express");
const bodyParser = require("body-parser");
const { v4: uuidv4 } = require("uuid");
const { ImapFlow } = require("imapflow");

let hap; // set by Homebridge

const PLUGIN_NAME = "homebridge-unifi-protect-webhook";
const PLATFORM_NAME = "ProtectWebhookPlatform";

module.exports = (api) => {
	hap = api.hap;
	api.registerPlatform(PLUGIN_NAME, PLATFORM_NAME, ProtectWebhookPlatform);
};

class ProtectWebhookPlatform {
	constructor(log, config, api) {
		this.log = log;
		this.api = api;
		this.config = config || {};

		this.accessories = new Map(); // name -> accessory
		this.webhooks = Array.isArray(this.config.webhooks) ? this.config.webhooks : [];
		this.emailTriggers = Array.isArray(this.config.emailTriggers) ? this.config.emailTriggers : [];
		this.adminSecret = this.config.adminSecret || null; // optional secret for admin endpoints

		// Security options
		this.bindAddress = this.config.bindAddress || "0.0.0.0"; // default: all interfaces (but we'll enforce local-only)
		this.port = this.config.port || 12050;
		this.enforceLocalOnly = this.config.enforceLocalOnly !== false; // default true

		// start once homebridge finished launching (so cached accessories are available)
		if (api) {
			this.api.on("didFinishLaunching", () => {
				try {
					this._initialize();
				} catch (e) {
					this.log.error("Initialization failed:", e);
				}
			});
		}
	}

	// Called for restored accessories from cache
	configureAccessory(accessory) {
		this.log.debug("Restoring accessory from cache:", accessory.displayName);
		this.accessories.set(accessory.context.key, accessory);
		// ensure service present
		const service = accessory.getService(hap.Service.MotionSensor) ||
			accessory.addService(hap.Service.MotionSensor, accessory.displayName);
		service.updateCharacteristic(hap.Characteristic.MotionDetected, false);
	}

	_initialize() {
		this._setupServer();
		this._setupWebhooks();
		this._setupEmailTriggers();
		this.log.info(`${PLUGIN_NAME} ready: ${this.webhooks.length} webhook(s), ${this.emailTriggers.length} email trigger(s)`);
	}

	// Express HTTP server with security guards
	_setupServer() {
		const app = express();
		app.disable("x-powered-by");
		app.use(bodyParser.json({ limit: "256kb" }));
		app.use(bodyParser.urlencoded({ extended: false }));

		// Basic request logger at debug level
		app.use((req, res, next) => {
			this.log.debug(`HTTP ${req.method} ${req.url} from ${this._getRemoteIp(req)}`);
			next();
		});

		// Security middleware: enforce local LAN only if enabled
		app.use((req, res, next) => {
			if (!this.enforceLocalOnly) return next();
			const ip = this._getRemoteIp(req);
			if (this._isPrivateIp(ip)) return next();
			this.log.warn(`Blocked non-local request from ${ip}`);
			return res.status(403).json({ error: "forbidden" });
		});

		// dynamic handlers will be registered in _setupWebhooks()
		this.server = app.listen(this.port, this.bindAddress, () => {
			this.log.info(`Webhook server listening on http://${this.bindAddress}:${this.port} (local-only=${this.enforceLocalOnly})`);
		});

		// keep for route registration
		this.app = app;

			// Admin endpoints (local only + adminSecret if set)
				app.get("/admin/webhooks/:name/token", (req, res) => {
				if (!this._isLocalAdminRequest(req)) return res.status(403).json({ error: "forbidden" });
				const name = req.params.name;
				const wh = this.webhooks.find(w => w.name === name);
				if (!wh) return res.status(404).json({ error: "not found" });
					// Reveal only once if autogenerated and not revealed yet
					const key = `webhook:${wh.name}`;
					const accessory = this.accessories.get(key);
					const revealed = accessory?.context?.tokenRevealed === true;
					const autogenerated = accessory?.context?.tokenAutogenerated === true || !!wh._autogenerated;
					if (!wh.token) return res.status(400).json({ error: "no token" });
					if (!autogenerated) {
						return res.status(400).json({ error: "token not autogenerated; manage it in config" });
					}
					if (revealed) {
						return res.status(410).json({ error: "token already revealed" });
					}
					if (accessory) {
						accessory.context.tokenRevealed = true;
						this.api.updatePlatformAccessories([accessory]);
					}
					return res.json({ name, token: wh.token, autogenerated: true, firstReveal: true });
			});

			app.post("/admin/webhooks/:name/regenerate", (req, res) => {
				if (!this._isLocalAdminRequest(req)) return res.status(403).json({ error: "forbidden" });
				const name = req.params.name;
				const wh = this.webhooks.find(w => w.name === name);
				if (!wh) return res.status(404).json({ error: "not found" });
						wh.token = uuidv4();
						wh._autogenerated = true; // mark as autogenerated
				const key = `webhook:${wh.name}`;
				const accessory = this.accessories.get(key);
				if (accessory) {
					accessory.context.token = wh.token;
							accessory.context.tokenAutogenerated = true;
							accessory.context.tokenRevealed = false;
					this.api.updatePlatformAccessories([accessory]);
				}
						return res.json({ name, token: wh.token, regenerated: true, firstReveal: true });
			});

		// graceful shutdown
		const shutdown = () => {
			try { this.server && this.server.close(); } catch (_) {}
		};
		process.on("SIGINT", shutdown);
		process.on("SIGTERM", shutdown);
	}

	_setupWebhooks() {
		for (const wh of this.webhooks) {
			const key = `webhook:${wh.name}`;
			const accessory = this._getOrCreateAccessory(key, wh.name);

			// Keep runtime control values
			wh._duration = Math.max(0, (wh.durationSeconds || 10)) * 1000;
			wh._debounce = Math.max(0, (wh.debounceSeconds || 0)) * 1000;
			wh._lastTrigger = 0;
			wh._id = accessory.UUID;

			// Prepare token: if not specified, use stored or generate
			const ctx = accessory.context || {};
					if (!wh.token) {
				if (ctx.token) {
					wh.token = ctx.token;
							wh._autogenerated = !!ctx.tokenAutogenerated;
				} else {
							wh.token = uuidv4();
							wh._autogenerated = true;
					ctx.token = wh.token;
							ctx.tokenAutogenerated = true;
							ctx.tokenRevealed = false;
					accessory.context = ctx;
					this.api.updatePlatformAccessories([accessory]);
							// Intenzionalmente non logghiamo il token; l'utente puÃ² recuperarlo via endpoint admin.
				}
			}

			// Compute path
			const basePath = wh.path && wh.path.trim().length > 0 ? wh.path.trim() : `/wh/${encodeURIComponent(wh.name.toLowerCase().replace(/\s+/g, "-"))}`;
			const fullPath = basePath.startsWith("/") ? basePath : `/${basePath}`;

			// Prepare optional allowlist
			const allowList = (wh.allowedIps || "")
				.split(",")
				.map((s) => s.trim())
				.filter(Boolean);

			const handler = async (req, res) => {
				const ip = this._getRemoteIp(req);
				if (allowList.length > 0 && !allowList.includes(ip)) {
					this.log.warn(`Webhook '${wh.name}' blocked by allowlist: ${ip}`);
					return res.status(403).json({ error: "forbidden" });
				}

				// Token header or query
				const token = req.get("x-webhook-token") || req.query.token || req.body?.token;
				if (!token || token !== wh.token) {
					this.log.warn(`Webhook '${wh.name}': invalid or missing token from ${ip}`);
					return res.status(401).json({ error: "unauthorized" });
				}

				// Debounce/cooldown
				const now = Date.now();
				if (wh._debounce > 0 && now - wh._lastTrigger < wh._debounce) {
					this.log.debug(`Webhook '${wh.name}' ignored by debounce (${now - wh._lastTrigger}ms < ${wh._debounce}ms)`);
					return res.json({ ok: true, debounced: true });
				}
				wh._lastTrigger = now;

				this._triggerAccessory(wh.name, accessory, wh._duration);
				this.log.info(`Webhook '${wh.name}' fired by ${ip}`);
				return res.json({ ok: true });
			};

			// Register both GET and POST
			this.app.get(fullPath, handler);
			this.app.post(fullPath, handler);

			this.log.info(`Webhook '${wh.name}' ready at ${fullPath} (token via header x-webhook-token or ?token=...)`);
		}
	}

	async _setupEmailTriggers() {
		for (const cfg of this.emailTriggers) {
			const key = `email:${cfg.name}`;
			const accessory = this._getOrCreateAccessory(key, cfg.name);
			cfg._duration = Math.max(0, (cfg.durationSeconds || 10)) * 1000;
			cfg._debounce = Math.max(0, (cfg.debounceSeconds || 0)) * 1000;
			cfg._lastTrigger = 0;
			cfg._id = accessory.UUID;

			try {
				await this._startImapMonitor(cfg, accessory);
				this.log.info(`Email trigger '${cfg.name}' monitoring ${cfg.imapUser}@${cfg.imapHost}`);
			} catch (e) {
				this.log.error(`Failed to start email trigger '${cfg.name}':`, e.message || e);
			}
		}
	}

		async _startImapMonitor(cfg, accessory) {
			const client = new ImapFlow({
				host: cfg.imapHost,
				port: cfg.imapPort || 993,
				secure: cfg.imapTls !== false,
				auth: { user: cfg.imapUser, pass: cfg.imapPassword },
				logger: false
			});

			const processUnseen = async () => {
				try {
					const uids = await client.search({ seen: false }, { uid: true });
					if (!uids || uids.length === 0) return;
					for (const uid of uids) {
						const msg = await client.fetchOne(uid, { envelope: true }, { uid: true });
						const subject = msg?.envelope?.subject || "";
						if (!subject) {
							// still mark seen to avoid loops
							await client.messageFlagsAdd(uid, ['\\Seen'], { uid: true });
							continue;
						}
						if (this._matchSubject(subject, cfg.subjectMatch)) {
							const now = Date.now();
							if (cfg._debounce && now - cfg._lastTrigger < cfg._debounce) {
								this.log.debug(`Email trigger '${cfg.name}' ignored by debounce`);
							} else {
								cfg._lastTrigger = now;
								this._triggerAccessory(cfg.name, accessory, cfg._duration);
								this.log.info(`Email trigger '${cfg.name}' fired (subject matched: "${subject}")`);
							}
						}
						// mark seen in any case to avoid re-processing
						try { await client.messageFlagsAdd(uid, ['\\Seen'], { uid: true }); } catch (_) {}
					}
				} catch (err) {
					this.log.error(`Error processing new mail for '${cfg.name}':`, err.message || err);
				}
			};

			const connectAndListen = async () => {
				await client.connect();
				await client.mailboxOpen('INBOX');
				await processUnseen();
				client.on('exists', processUnseen);
				client.on('expunge', () => {});
			};

			client.on('error', (err) => {
				this.log.warn(`IMAP error for '${cfg.name}':`, err?.message || err);
			});

			try {
				await connectAndListen();
			} catch (e) {
				this.log.error(`Failed to start email trigger '${cfg.name}':`, e?.message || e);
				// retry later
				setTimeout(() => this._startImapMonitor(cfg, accessory).catch(err => this.log.error('IMAP reconnect failed', err)), 5000);
				return;
			}

			cfg._imap = client;
		}

	_getOrCreateAccessory(key, displayName) {
		const uuid = this.api.hap.uuid.generate(`${PLATFORM_NAME}:${key}`);
		let accessory = this.accessories.get(key);
		if (accessory) {
			accessory.displayName = displayName;
		} else {
			accessory = new this.api.platformAccessory(displayName, uuid);
			accessory.context = { key };
			accessory.category = hap.Categories.SENSOR;
			accessory.addService(hap.Service.MotionSensor, displayName);
			this.api.registerPlatformAccessories(PLUGIN_NAME, PLATFORM_NAME, [accessory]);
			this.log.info(`Registered accessory '${displayName}'`);
		}
		this.accessories.set(key, accessory);
		return accessory;
	}

	_triggerAccessory(name, accessory, durationMs) {
		const service = accessory.getService(hap.Service.MotionSensor);
		service.updateCharacteristic(hap.Characteristic.MotionDetected, true);
		if (accessory._resetTimer) clearTimeout(accessory._resetTimer);
		accessory._resetTimer = setTimeout(() => {
			service.updateCharacteristic(hap.Characteristic.MotionDetected, false);
		}, Math.max(0, durationMs || 10000));
		this.log.debug(`Accessory '${name}' set to ON for ${Math.max(0, durationMs || 10000)}ms`);
	}

	_matchSubject(subject, pattern) {
		if (!pattern) return false;
		try {
			const rx = new RegExp(pattern);
			return rx.test(subject);
		} catch (_) {
			return subject.includes(String(pattern));
		}
	}

	_getRemoteIp(req) {
		// Do not trust proxies by default
		const ip = (req.socket && req.socket.remoteAddress) || req.ip || "";
		// strip IPv6 prefix ::ffff:
		return ip.startsWith("::ffff:") ? ip.substring(7) : ip;
	}

	_isPrivateIp(ip) {
		// RFC1918 + loopback + link-local
		return (
			ip === "127.0.0.1" ||
			ip === "::1" ||
			ip.startsWith("10.") ||
			ip.startsWith("192.168.") ||
			/^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(ip) ||
			ip.startsWith("169.254.")
		);
	}

		_isLocalAdminRequest(req) {
			const ip = this._getRemoteIp(req);
			if (!this._isPrivateIp(ip)) return false;
			if (this.adminSecret) {
				const provided = req.get("x-admin-secret") || req.query.adminSecret;
				if (!provided || provided !== this.adminSecret) return false;
			}
			return true;
		}

	// Cleanup on shutdown
	async shutdown() {
		try { this.server && this.server.close(); } catch (_) {}
		for (const cfg of this.emailTriggers) {
			if (cfg._keepAliveTimer) clearInterval(cfg._keepAliveTimer);
			try { cfg._imap && cfg._imap.end(); } catch (_) {}
		}
	}
}
