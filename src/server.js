"use strict";

const express = require("express");
const bodyParser = require("body-parser");
const { v4: uuidv4 } = require("uuid");
const Logger = require("./logger");

// Async error wrapper for Express routes
function asyncHandler(fn) {
	return (req, res, next) => {
		Promise.resolve(fn(req, res, next)).catch((err) => {
			Logger.global.error("Unhandled error in route handler:", err);
			if (!res.headersSent) {
				res.status(500).json({ error: "internal server error" });
			}
			next(err);
		});
	};
}

module.exports = function createServer(platform) {
	const logger = Logger.global;
	
	try {
		logger.diagnostic("Creating Express app...");
		const app = express();
		app.disable("x-powered-by");
		app.use(bodyParser.json({ limit: "256kb" }));
		app.use(bodyParser.urlencoded({ extended: false }));

		// Basic request logger at debug level (with redaction)
		app.use((req, res, next) => {
			try {
				const redactedUrl = platform._redactUrl(req.url);
				platform.logger.debug(`HTTP ${req.method} ${redactedUrl} from ${platform._getRemoteIp(req)}`);
				next();
			} catch (err) {
				logger.error("Error in request logger middleware:", err);
				next();
			}
		});

	// Security middleware: enforce local LAN only if enabled
	app.use((req, res, next) => {
		if (!platform.enforceLocalOnly) return next();
		const ip = platform._getRemoteIp(req);
		if (platform._isPrivateIp(ip)) return next();
		platform.log.warn(`Blocked non-local request from ${ip}`);
		return res.status(403).json({ error: "forbidden" });
	});

	// Admin endpoints (local only + adminSecret if set)
	// Reveal token (only once if autogenerated)
	app.get("/admin/webhooks/:name/token", (req, res) => {
		if (!platform._isLocalAdminRequest(req)) return res.status(403).json({ error: "forbidden" });
		const name = req.params.name;
		const wh = platform.webhooks.find(w => w.name === name);
		if (!wh) return res.status(404).json({ error: "not found" });
		// Reveal only once if autogenerated and not revealed yet
		const key = `webhook:${wh.name}`;
		const accessory = platform.accessories.get(key);
		const revealed = accessory?.context?.tokenRevealed === true;
		const autogenerated = accessory?.context?.tokenAutogenerated === true || !!wh._autogenerated;
		if (!wh.token) return res.status(400).json({ error: "no token" });
		if (!autogenerated) {
			return res.status(400).json({ error: "token not autogenerated; manage it in config" });
		}
		if (revealed) {
			return res.status(410).json({ error: "token already revealed" });
		}
		if (accessory) {
			accessory.context.tokenRevealed = true;
			platform.api.updatePlatformAccessories([accessory]);
		}
		const url = platform._composeWebhookUrl(req, wh);
		platform.logger.info(`Admin token reveal for '${name}' from ${platform._getRemoteIp(req)} (firstReveal=${true})`);
		return res.json({ name, token: wh.token, url, autogenerated: true, firstReveal: true });
	});

	// Generate ephemeral token + full URL (no side effects on permanent token)
	app.post("/admin/webhooks/:name/ephemeral", (req, res) => {
		if (!platform._isLocalAdminRequest(req)) return res.status(403).json({ error: "forbidden" });
		const name = req.params.name;
		const wh = platform.webhooks.find(w => w.name === name);
		if (!wh) return res.status(404).json({ error: "not found" });
		const ttlSec = Math.max(10, Math.min(3600, parseInt(req.query.ttl || req.body?.ttl || 300)));
		const ep = platform._addEphemeralToken(wh.name, uuidv4(), ttlSec * 1000);
		const path = platform._computeWebhookPath(wh);
		const base = platform._serverBaseUrl(req);
		const url = `${base}${path}?token=${encodeURIComponent(ep.token)}`;
		return res.json({ name, path, url, expiresAt: ep.expiresAt, ttlSeconds: ttlSec, ephemeral: true });
	});

	// Regenerate token and return first-reveal info
	app.post("/admin/webhooks/:name/regenerate", (req, res) => {
		if (!platform._isLocalAdminRequest(req)) return res.status(403).json({ error: "forbidden" });
		const name = req.params.name;
		const wh = platform.webhooks.find(w => w.name === name);
		if (!wh) return res.status(404).json({ error: "not found" });
		wh.token = uuidv4();
		wh._autogenerated = true; // mark as autogenerated
		const key = `webhook:${wh.name}`;
		const accessory = platform.accessories.get(key);
		if (accessory) {
			accessory.context.token = wh.token;
			accessory.context.tokenAutogenerated = true;
			accessory.context.tokenRevealed = false;
			platform.api.updatePlatformAccessories([accessory]);
		}
		const url = platform._composeWebhookUrl(req, wh);
		platform.logger.info(`Admin token regenerate for '${name}' from ${platform._getRemoteIp(req)}`);
		return res.json({ name, token: wh.token, url, regenerated: true, firstReveal: true });
	});

	// List webhooks (names and paths only, no tokens)
	app.get("/admin/webhooks", (req, res) => {
		if (!platform._isLocalAdminRequest(req)) return res.status(403).json({ error: "forbidden" });
		const list = platform.webhooks.map((w) => ({ name: w.name, path: platform._computeWebhookPath(w) }));
		return res.json({ webhooks: list });
	});

	// Get webhook info and a safe URL (token redacted unless first reveal)
	app.get("/admin/webhooks/:name/info", (req, res) => {
		if (!platform._isLocalAdminRequest(req)) return res.status(403).json({ error: "forbidden" });
		const name = req.params.name;
		const wh = platform.webhooks.find(w => w.name === name);
		if (!wh) return res.status(404).json({ error: "not found" });
		const key = `webhook:${wh.name}`;
		const accessory = platform.accessories.get(key);
		const autogenerated = accessory?.context?.tokenAutogenerated === true || !!wh._autogenerated;
		const revealed = accessory?.context?.tokenRevealed === true;
		const path = platform._computeWebhookPath(wh);
		const base = platform._serverBaseUrl(req);
		let url = `${base}${path}`;
		if (wh.token) {
			if (autogenerated && !revealed) {
				url = `${url}?token=REDACTED`;
			} else {
				url = `${url}?token=${encodeURIComponent(wh.token)}`;
			}
		}
		return res.json({ name, path, url, tokenAutogenerated: !!autogenerated, tokenFirstRevealed: !!revealed });
	});

	// UI state endpoint (safe data for custom UI in Homebridge UI X)
	app.get("/admin/state", (req, res) => {
		if (!platform._isLocalAdminRequest(req)) return res.status(403).json({ error: "forbidden" });
		const base = platform._serverBaseUrl(req);
		const webhooks = platform.webhooks.map((w) => {
			const key = `webhook:${w.name}`;
			const accessory = platform.accessories.get(key);
			const revealed = accessory?.context?.tokenRevealed === true;
			const pathValue = platform._computeWebhookPath(w);
			return {
				name: w.name,
				path: pathValue,
				url: `${base}${pathValue}`,
				revealed,
				permanentToken: revealed ? w.token : null
			};
		});
		const emails = platform.emailTriggers.map((e) => ({
			name: e.name,
			imapHost: e.imapHost,
			debounceSeconds: e.debounceSeconds || 0,
			durationSeconds: e.durationSeconds || 10
		}));
		return res.json({ webhooks, emailTriggers: emails });
	});

	// Nota: la UI è ora integrata in Homebridge UI X tramite `homebridge-ui/`.
	// Non serviamo più una pagina esterna su /admin/ui.

		logger.diagnostic("Starting HTTP server...");
		const server = app.listen(platform.port, platform.bindAddress, () => {
			platform.logger.info(`Webhook server listening on ${platform._serverBaseUrl()} (local-only=${platform.enforceLocalOnly})`);
			logger.success("HTTP server started successfully");
		});

		// Error handler for server
		server.on('error', (err) => {
			logger.error("HTTP server error:", err);
			platform.logger.error("HTTP server error:", err);
		});

		// graceful shutdown
		const shutdown = () => {
			logger.diagnostic("Shutting down HTTP server...");
			try { 
				server && server.close(() => {
					logger.diagnostic("HTTP server closed");
				}); 
			} catch (err) {
				logger.error("Error closing HTTP server:", err);
			}
		};
		process.on("SIGINT", shutdown);
		process.on("SIGTERM", shutdown);

		return { app, server };
		
	} catch (err) {
		logger.error("CRITICAL: Failed to create HTTP server:", err);
		platform.logger.error("CRITICAL: Failed to create HTTP server:", err);
		throw err;
	}
}
