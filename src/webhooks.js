"use strict";

const { v4: uuidv4 } = require("uuid");
const Logger = require("./logger");

module.exports = function setupWebhooks(platform) {
	const logger = Logger.global;
	
	if (!platform.webhooks || platform.webhooks.length === 0) {
		logger.diagnostic("No webhooks configured");
		return;
	}
	
	logger.diagnostic(`Setting up ${platform.webhooks.length} webhook(s)...`);
	
	for (const wh of platform.webhooks) {
		try {
			logger.diagnostic(`  Setting up webhook: ${wh.name}`);
			const key = `webhook:${wh.name}`;
			const accessory = platform._getOrCreateAccessory(key, wh.name);

		// Keep runtime control values
		wh._duration = Math.max(0, (wh.durationSeconds || 10)) * 1000;
		wh._debounce = Math.max(0, (wh.debounceSeconds || 0)) * 1000;
		wh._lastTrigger = 0;
		wh._id = accessory.UUID;

		// Prepare token: if not specified, use stored or generate
		const ctx = accessory.context || {};
		if (!wh.token) {
			if (ctx.token) {
				wh.token = ctx.token;
				wh._autogenerated = !!ctx.tokenAutogenerated;
			} else {
				wh.token = uuidv4();
				wh._autogenerated = true;
				ctx.token = wh.token;
				ctx.tokenAutogenerated = true;
				ctx.tokenRevealed = false;
				accessory.context = ctx;
				platform.api.updatePlatformAccessories([accessory]);
				// Intenzionalmente non logghiamo il token; l'utente puÃ² recuperarlo via endpoint admin.
			}
		}

		// Compute path
		const fullPath = platform._computeWebhookPath(wh);

		// Prepare optional allowlist
		const allowList = (wh.allowedIps || "")
			.split(",")
			.map((s) => s.trim())
			.filter(Boolean);

		const handler = async (req, res) => {
			const ip = platform._getRemoteIp(req);
			if (allowList.length > 0 && !allowList.includes(ip)) {
				platform.log.warn(`Webhook '${wh.name}' blocked by allowlist: ${ip}`);
				return res.status(403).json({ error: "forbidden" });
			}


			// Token header or query (supports ephemeral tokens)
			const token = req.get("x-webhook-token") || req.query.token || req.body?.token;
			const valid = !!token && (token === wh.token || platform._isEphemeralTokenValid(wh.name, token));
			if (!valid) {
				platform.log.warn(`Webhook '${wh.name}': invalid or missing token from ${ip}`);
				return res.status(401).json({ error: "unauthorized" });
			}

			// Debounce/cooldown
			const now = Date.now();
			if (wh._debounce > 0 && now - wh._lastTrigger < wh._debounce) {
				platform.log.debug(`Webhook '${wh.name}' ignored by debounce (${now - wh._lastTrigger}ms < ${wh._debounce}ms)`);
				return res.json({ ok: true, debounced: true });
			}
			wh._lastTrigger = now;

			platform._triggerAccessory(wh.name, accessory, wh._duration);
			platform.log.info(`Webhook '${wh.name}' fired by ${ip}`);
			return res.json({ ok: true });
		};

		// Register both GET and POST
			platform.app.get(fullPath, handler);
			platform.app.post(fullPath, handler);

			platform.logger.info(`Webhook '${wh.name}' ready at ${platform._serverBaseUrl()}${fullPath} (token via header x-webhook-token or ?token=...)`);
			logger.success(`  Webhook '${wh.name}' configured successfully`);
			
		} catch (err) {
			logger.error(`CRITICAL: Failed to setup webhook '${wh.name}':`, err);
			platform.logger.error(`Failed to setup webhook '${wh.name}':`, err);
			// Continue with other webhooks instead of failing completely
		}
	}
	
	logger.diagnostic("Webhooks setup complete");
}
